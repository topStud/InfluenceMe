import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @jsx jsx */
import { jsx } from '@emotion/core';
import { Component } from 'react';
import RadioIcon from '@atlaskit/icon/glyph/radio';
import CheckboxIcon from '@atlaskit/icon/glyph/checkbox';
import { themed } from '@atlaskit/theme/components';
import { gridSize } from '@atlaskit/theme/constants';
import { B100, B200, B300, B400, B75, DN200, DN10, DN30, N20A, N0, N100, N20, N30, N70 } from '@atlaskit/theme/colors';
import { token } from '@atlaskit/tokens';

var getPrimitiveStyles = function getPrimitiveStyles(props) {
  var cx = props.cx,
      className = props.className,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      isSelected = props.isSelected;
  var styles = {
    alignItems: 'center',
    backgroundColor: isFocused ? token('color.background.transparentNeutral.hover', N20) : 'transparent',
    color: isDisabled ? token('color.text.disabled', 'inherit') : 'inherit',
    display: 'flex ',
    paddingBottom: 4,
    paddingLeft: "".concat(gridSize() * 2, "px"),
    paddingTop: 4,
    boxShadow: isFocused ? "inset 2px 0px 0px ".concat(token('color.text.selected', B400), ";") : '',
    ':active': {
      backgroundColor: token('color.background.transparentNeutral.pressed', N30)
    },
    '@media screen and (-ms-high-contrast: active)': {
      borderLeft: isFocused ? '2px solid transparent' : ''
    }
  };

  var augmentedStyles = _objectSpread(_objectSpread({}, getStyles('option', props)), styles);

  var bemClasses = {
    option: true,
    'option--is-disabled': isDisabled,
    'option--is-focused': isFocused,
    'option--is-selected': isSelected
  }; // maintain react-select API

  return [augmentedStyles, cx(bemClasses, className)];
}; // maintains function shape


var backgroundColor = themed({
  light: token('color.background.subtleNeutral.resting', N0),
  dark: token('color.background.subtleNeutral.resting', DN10)
});
var transparent = themed({
  light: 'transparent',
  dark: 'transparent'
}); // state of the parent option

// the primary color represents the outer or background element
var getPrimaryColor = function getPrimaryColor(_ref) {
  var isActive = _ref.isActive,
      isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      isSelected = _ref.isSelected,
      rest = _objectWithoutProperties(_ref, ["isActive", "isDisabled", "isFocused", "isSelected"]);

  var color = backgroundColor;

  if (isDisabled && isSelected) {
    color = themed({
      light: token('color.background.disabled', B75),
      dark: token('color.background.disabled', DN200)
    });
  } else if (isDisabled) {
    color = themed({
      light: token('color.background.disabled', N20A),
      dark: token('color.background.disabled', DN10)
    });
  } else if (isSelected && isActive) {
    color = themed({
      light: token('color.background.boldBrand.pressed', B75),
      dark: token('color.background.boldBrand.pressed', B200)
    });
  } else if (isActive) {
    color = themed({
      light: token('color.background.subtleBrand.pressed', B75),
      dark: token('color.background.subtleBrand.pressed', B200)
    });
  } else if (isFocused && isSelected) {
    color = themed({
      light: token('color.background.boldBrand.hover', B300),
      dark: token('color.background.boldBrand.hover', B75)
    });
  } else if (isFocused) {
    color = themed({
      light: token('color.background.default', N0),
      dark: token('color.background.default', DN30)
    });
  } else if (isSelected) {
    color = themed({
      light: token('color.background.boldBrand.resting', B400),
      dark: token('color.background.boldBrand.resting', B100)
    });
  }

  return color(rest);
}; // the secondary color represents the radio dot or checkmark


var getSecondaryColor = function getSecondaryColor(_ref2) {
  var isActive = _ref2.isActive,
      isDisabled = _ref2.isDisabled,
      isSelected = _ref2.isSelected,
      rest = _objectWithoutProperties(_ref2, ["isActive", "isDisabled", "isSelected"]);

  var color = themed({
    light: token('color.background.default', N0),
    dark: token('color.background.default', DN10)
  });

  if (isDisabled && isSelected) {
    color = themed({
      light: token('color.text.disabled', N70),
      dark: token('color.text.disabled', DN10)
    });
  } else if (isActive && isSelected && !isDisabled) {
    color = themed({
      light: token('color.background.default', B400),
      dark: token('color.background.default', DN10)
    });
  } else if (!isSelected) {
    color = transparent;
  }

  return color(rest);
}; // the border color surrounds the checkbox/radio


var getBorderColor = function getBorderColor(_ref3) {
  var isActive = _ref3.isActive,
      isDisabled = _ref3.isDisabled,
      isFocused = _ref3.isFocused,
      isSelected = _ref3.isSelected,
      rest = _objectWithoutProperties(_ref3, ["isActive", "isDisabled", "isFocused", "isSelected"]);

  if (isDisabled && isSelected) {
    return token('color.background.disabled', B400);
  } else if (isDisabled) {
    return token('color.background.disabled', N100);
  } else if (isSelected && isActive) {
    return token('color.background.boldBrand.pressed', B400);
  } else if (isActive) {
    return token('color.background.boldBrand.resting', B400);
  } else if (isFocused && isSelected) {
    return token('color.background.boldBrand.hover', B400);
  } else if (isFocused) {
    return token('color.border.neutral', N100);
  } else if (isSelected) {
    return token('color.background.boldBrand.resting', B400);
  }

  return token('color.border.neutral', N100);
};

var ControlOption = /*#__PURE__*/function (_Component) {
  _inherits(ControlOption, _Component);

  var _super = _createSuper(ControlOption);

  function ControlOption() {
    var _this;

    _classCallCheck(this, ControlOption);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      isActive: false
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function () {
      return _this.setState({
        isActive: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function () {
      return _this.setState({
        isActive: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseLeave", function () {
      return _this.setState({
        isActive: false
      });
    });

    return _this;
  }

  _createClass(ControlOption, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          getStyles = _this$props.getStyles,
          Icon = _this$props.Icon,
          children = _this$props.children,
          innerProps = _this$props.innerProps,
          innerRef = _this$props.innerRef,
          rest = _objectWithoutProperties(_this$props, ["getStyles", "Icon", "children", "innerProps", "innerRef"]); // prop assignment


      var props = _objectSpread(_objectSpread({}, innerProps), {}, {
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        onMouseLeave: this.onMouseLeave
      });

      var _getPrimitiveStyles = getPrimitiveStyles(_objectSpread({
        getStyles: getStyles
      }, rest)),
          _getPrimitiveStyles2 = _slicedToArray(_getPrimitiveStyles, 2),
          styles = _getPrimitiveStyles2[0],
          classes = _getPrimitiveStyles2[1];

      return jsx("div", _extends({
        css: styles,
        className: classes,
        ref: innerRef
      }, props), jsx("div", {
        css: {
          alignItems: 'center',
          display: 'flex ',
          flexShrink: 0,
          paddingRight: '4px',
          // Here we are adding a border to the Checkbox and Radio SVG icons
          // This is an a11y fix for Select only for now but it may be rolled
          // into the `@atlaskit/icon` package's Checkbox and Radio SVGs later
          '& svg rect, & svg circle:first-of-type': {
            stroke: getBorderColor(_objectSpread(_objectSpread({}, this.props), this.state)),
            strokeWidth: '2px',
            strokeLinejoin: 'round'
          }
        }
      }, !!Icon ? jsx(Icon, {
        label: "",
        primaryColor: getPrimaryColor(_objectSpread(_objectSpread({}, this.props), this.state)),
        secondaryColor: getSecondaryColor(_objectSpread(_objectSpread({}, this.props), this.state))
      }) : null), jsx("div", {
        css: {
          textOverflow: 'ellipsis',
          overflowX: 'hidden',
          flexGrow: 1,
          whiteSpace: 'nowrap'
        }
      }, children));
    }
  }]);

  return ControlOption;
}(Component);

export var CheckboxOption = function CheckboxOption(props) {
  return jsx(ControlOption, _extends({
    Icon: CheckboxIcon
  }, props));
};
export var RadioOption = function RadioOption(props) {
  return jsx(ControlOption, _extends({
    Icon: RadioIcon
  }, props));
};
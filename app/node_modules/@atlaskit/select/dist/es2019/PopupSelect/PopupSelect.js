import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { PureComponent } from 'react';
import { createPortal } from 'react-dom';
import Select, { mergeStyles } from 'react-select';
import { uid } from 'react-uid';
import createFocusTrap from 'focus-trap';
import { Manager, Reference, Popper } from 'react-popper';
import NodeResolver from 'react-node-resolver';
import shallowEqualObjects from 'shallow-equal/objects';
import { N80 } from '@atlaskit/theme/colors';
import { token } from '@atlaskit/tokens';
import { MenuDialog, DummyControl, defaultComponents } from './components';
import baseStyles from '../styles';

/** Are we rendering on the client or server? */
const canUseDOM = () => Boolean(typeof window !== 'undefined' && window.document && window.document.createElement); // ==============================
// Types
// ==============================


// ==============================
// Class
// ==============================
const defaultPopperProps = {
  modifiers: [{
    name: 'offset',
    options: {
      offset: [0, 8]
    }
  }, {
    name: 'preventOverflow',
    enabled: true,
    options: {
      padding: 5,
      boundary: 'clippingParents',
      altAxis: true,
      altBoundary: true
    }
  }],
  placement: 'bottom-start'
};

const isEmpty = obj => Object.keys(obj).length === 0;

export default class PopupSelect extends PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "focusTrap", null);

    _defineProperty(this, "menuRef", null);

    _defineProperty(this, "selectRef", null);

    _defineProperty(this, "targetRef", null);

    _defineProperty(this, "defaultStyles", mergeStyles(baseStyles(this.props.validationState, this.props.spacing === 'compact'), {
      groupHeading: provided => ({ ...provided,
        color: token('color.text.lowEmphasis', N80)
      })
    }));

    _defineProperty(this, "state", {
      isOpen: false,
      mergedComponents: defaultComponents,
      mergedPopperProps: defaultPopperProps
    });

    _defineProperty(this, "popperWrapperId", `${uid({
      options: this.props.options
    })}-popup-select`);

    _defineProperty(this, "handleKeyDown", event => {
      switch (event.key) {
        case 'Escape':
        case 'Esc':
          this.close();
          break;

        default:
      }

      if (this.props.handleKeyDown) {
        this.props.handleKeyDown(event);
      }
    });

    _defineProperty(this, "handleClick", ({
      target
    }) => {
      const {
        isOpen
      } = this.state; // appease flow

      if (!(target instanceof Element)) {
        return;
      } // NOTE: Why not use the <Blanket /> component to close?
      // We don't want to interupt the user's flow. Taking this approach allows
      // user to click "through" to other elements and close the popout.


      if (isOpen && this.menuRef && !this.menuRef.contains(target)) {
        this.close();
      } // open on target click -- we can't trust consumers to spread the onClick
      // property to the target


      if (!isOpen && this.targetRef && this.targetRef.contains(target)) {
        this.open();
      }
    });

    _defineProperty(this, "handleSelectChange", (value, actionMeta) => {
      const {
        closeMenuOnSelect,
        onChange
      } = this.props;

      if (closeMenuOnSelect && actionMeta.action !== 'clear') {
        this.close();
      }

      if (onChange) {
        onChange(value, actionMeta);
      }
    });

    _defineProperty(this, "open", () => {
      const {
        onOpen
      } = this.props;

      if (onOpen) {
        onOpen();
      }

      this.setState({
        isOpen: true
      }, this.initialiseFocusTrap);

      if (this.selectRef) {
        this.selectRef.select.openMenu('first'); // HACK
      }

      if (typeof window === 'undefined') {
        return;
      }

      window.addEventListener('keydown', this.handleKeyDown, true);
    });

    _defineProperty(this, "initialiseFocusTrap", () => {
      if (!this.menuRef) {
        return;
      }

      const trapConfig = {
        clickOutsideDeactivates: true,
        escapeDeactivates: true,
        fallbackFocus: this.menuRef,
        returnFocusOnDeactivate: true
      };
      this.focusTrap = createFocusTrap(this.menuRef, trapConfig); // allow time for the HTMLElement to render

      setTimeout(() => this.focusTrap.activate(), 1);
    });

    _defineProperty(this, "close", () => {
      const {
        onClose
      } = this.props;

      if (onClose) {
        onClose();
      }

      this.setState({
        isOpen: false
      });

      if (this.focusTrap) {
        this.focusTrap.deactivate();
      }

      if (typeof window === 'undefined') {
        return;
      }

      window.removeEventListener('keydown', this.handleKeyDown, true);
    });

    _defineProperty(this, "resolveTargetRef", popperRef => ref => {
      // avoid thrashing fn calls
      if (!this.targetRef && popperRef && ref) {
        this.targetRef = ref;

        if (typeof popperRef === 'function') {
          popperRef(ref);
        } else {
          popperRef.current = ref;
        }
      }
    });

    _defineProperty(this, "resolveMenuRef", popperRef => ref => {
      this.menuRef = ref;

      if (typeof popperRef === 'function') {
        popperRef(ref);
      } else {
        popperRef.current = ref;
      }
    });

    _defineProperty(this, "getSelectRef", ref => {
      this.selectRef = ref;
    });

    _defineProperty(this, "getItemCount", () => {
      const {
        options
      } = this.props;
      let count = 0;
      options.forEach(groupOrOption => {
        if (groupOrOption.options) {
          groupOrOption.options.forEach(() => count++);
        } else {
          count++;
        }
      });
      return count;
    });

    _defineProperty(this, "getMaxHeight", () => {
      const {
        maxMenuHeight
      } = this.props;

      if (!this.selectRef) {
        return maxMenuHeight;
      } // subtract the control height to maintain consistency


      const showSearchControl = this.showSearchControl();
      const {
        controlRef
      } = this.selectRef.select; // @ts-ignore React-select provides incomplete types for controlRef

      const offsetHeight = showSearchControl ? controlRef.offsetHeight : 0;
      const maxHeight = maxMenuHeight - offsetHeight;
      return maxHeight;
    });

    _defineProperty(this, "showSearchControl", () => {
      const {
        searchThreshold
      } = this.props;
      return this.getItemCount() > searchThreshold;
    });

    _defineProperty(this, "renderSelect", () => {
      const {
        footer,
        maxMenuWidth,
        minMenuWidth,
        target,
        ...props
      } = this.props;
      const {
        isOpen,
        mergedComponents,
        mergedPopperProps
      } = this.state;
      const showSearchControl = this.showSearchControl();
      const portalDestination = canUseDOM() ? document.body : null;
      const components = { ...mergedComponents,
        Control: showSearchControl ? mergedComponents.Control : DummyControl
      };

      if (!portalDestination || !isOpen) {
        return null;
      }

      const popper = /*#__PURE__*/React.createElement(Popper, mergedPopperProps, ({
        placement,
        ref,
        style
      }) => {
        return /*#__PURE__*/React.createElement(NodeResolver, {
          innerRef: this.resolveMenuRef(ref)
        }, /*#__PURE__*/React.createElement(MenuDialog, {
          style: style,
          "data-placement": placement,
          minWidth: minMenuWidth,
          maxWidth: maxMenuWidth,
          id: this.popperWrapperId
        }, /*#__PURE__*/React.createElement(Select, _extends({
          backspaceRemovesValue: false,
          controlShouldRenderValue: false,
          isClearable: false,
          tabSelectsValue: false,
          menuIsOpen: true,
          ref: this.getSelectRef
        }, props, {
          isSearchable: showSearchControl,
          styles: { ...this.defaultStyles,
            ...props.styles
          },
          maxMenuHeight: this.getMaxHeight(),
          components: components,
          onChange: this.handleSelectChange
        })), footer));
      });
      return mergedPopperProps.strategy === 'fixed' ? popper : /*#__PURE__*/createPortal(popper, portalDestination);
    });
  }

  static getDerivedStateFromProps(props, state) {
    const newState = {}; // Merge consumer and default popper props

    const mergedPopperProps = { ...defaultPopperProps,
      ...props.popperProps
    };

    if (!shallowEqualObjects(mergedPopperProps, state.mergedPopperProps)) {
      newState.mergedPopperProps = mergedPopperProps;
    } // Merge consumer and default components


    const mergedComponents = { ...defaultComponents,
      ...props.components
    };

    if (!shallowEqualObjects(mergedComponents, state.mergedComponents)) {
      newState.mergedComponents = mergedComponents;
    }

    if (!isEmpty(newState)) {
      return newState;
    }

    return null;
  }

  componentDidMount() {
    if (typeof window === 'undefined') {
      return;
    }

    window.addEventListener('click', this.handleClick, true);
  }

  componentWillUnmount() {
    if (typeof window === 'undefined') {
      return;
    }

    window.removeEventListener('click', this.handleClick, true);
    window.removeEventListener('keydown', this.handleKeyDown, true);
  } // Event Handlers
  // ==============================


  render() {
    const {
      target
    } = this.props;
    const {
      isOpen
    } = this.state;
    return /*#__PURE__*/React.createElement(Manager, null, /*#__PURE__*/React.createElement(Reference, null, ({
      ref
    }) => target && target({
      isOpen,
      ref: this.resolveTargetRef(ref),
      'aria-haspopup': 'true',
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? this.popperWrapperId : undefined
    })), this.renderSelect());
  }

}

_defineProperty(PopupSelect, "defaultProps", {
  closeMenuOnSelect: true,
  components: {},
  maxMenuHeight: 300,
  maxMenuWidth: 440,
  minMenuWidth: 220,
  popperProps: {},
  searchThreshold: 5,
  styles: {},
  options: []
});